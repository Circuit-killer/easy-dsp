{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome\n\n\nYou will find explanations about how to use the project (how to start, the different commands available), and how to develop on it (the global structure, the different components, their interactions and details about the C and Javascript code).", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome", 
            "text": "You will find explanations about how to use the project (how to start, the different commands available), and how to develop on it (the global structure, the different components, their interactions and details about the C and Javascript code).", 
            "title": "Welcome"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting Started\n\n\nYou will find explanations about how to use the project (how to start, the different commands available), and how to develop on it (the global structure, the different components, their interactions and details about the C and Javascript code).\n\n\nOn the board\n\n\nPrerequisites\n\n\n\n\nlibwebsock\n;\n\n\nJansson\n.\n\n\n\n\nCompilation\n\n\nmake\n should be enough to compile the three programs.\n\n\nLaunch\n\n\nTwo possibilities: \n./start.sh log-file.txt\n (recommended) or:\n\n\n./browser-main-daemon \n\nexport LD_LIBRARY_PATH=/usr/local/lib\n./browser-wsaudio \n\n./browser-wsconfig \n\n\n\n\nTo stop it, kill the three programs (or use \n./stop.sh\n).\n\n\nOn the computer\n\n\nPrerequisites\n\n\n\n\nInstall \nws4py\n;\n\n\nClone \nRickshaw\n in the directory of the \nclient.html\n file: \ngit clone https://github.com/shutterstock/rickshaw.git\n.\n\n\n\n\nConfiguration\n\n\nThe IP address of the board must be specified in two files:\n\n\n\n\nLines 8 and 9 of \njs/main.js\n;\n\n\nAt the end of \nbase-program.py\n.\n\n\n\n\nLaunch\n\n\n\n\nYou first have to launch the python daemon: \npython code-server.py\n;\n\n\nThen you just have to open the file \nclient.html\n in your browser.", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "You will find explanations about how to use the project (how to start, the different commands available), and how to develop on it (the global structure, the different components, their interactions and details about the C and Javascript code).", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#on-the-board", 
            "text": "", 
            "title": "On the board"
        }, 
        {
            "location": "/getting-started/#prerequisites", 
            "text": "libwebsock ;  Jansson .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/getting-started/#compilation", 
            "text": "make  should be enough to compile the three programs.", 
            "title": "Compilation"
        }, 
        {
            "location": "/getting-started/#launch", 
            "text": "Two possibilities:  ./start.sh log-file.txt  (recommended) or:  ./browser-main-daemon  \nexport LD_LIBRARY_PATH=/usr/local/lib\n./browser-wsaudio  \n./browser-wsconfig    To stop it, kill the three programs (or use  ./stop.sh ).", 
            "title": "Launch"
        }, 
        {
            "location": "/getting-started/#on-the-computer", 
            "text": "", 
            "title": "On the computer"
        }, 
        {
            "location": "/getting-started/#prerequisites_1", 
            "text": "Install  ws4py ;  Clone  Rickshaw  in the directory of the  client.html  file:  git clone https://github.com/shutterstock/rickshaw.git .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/getting-started/#configuration", 
            "text": "The IP address of the board must be specified in two files:   Lines 8 and 9 of  js/main.js ;  At the end of  base-program.py .", 
            "title": "Configuration"
        }, 
        {
            "location": "/getting-started/#launch_1", 
            "text": "You first have to launch the python daemon:  python code-server.py ;  Then you just have to open the file  client.html  in your browser.", 
            "title": "Launch"
        }, 
        {
            "location": "/structure/", 
            "text": "Intro\n\n\nHere is the global structure of the project, and how the different parts interact.\n\n\nOverview\n\n\nThe system is divided in three parts:\n\n\n\n\nDaemons in C running on the board;\n\n\nA Python daemon running on the client computer;\n\n\nA webapp executed on the client computer.\n\n\n\n\nThese three parts communicate using \nWebSockets\n (basically a TCP connection, that you can use easily in Javascript, in browsers).\n\n\n\n\nOn the Board\n\n\nThere are three daemons running on the board, all in C:\n\n\n\n\nThe \nmain-daemon\n is the main part of the system, and the only one interacting with the microphones through ALSA API;\n\n\nThe \nws-audio\n is a first bridge between the main daemon and a WebSocket, allowing external clients to access the audio streams;\n\n\nThe \nws-config\n is a second bridge between the main daemon and a WebSocket, allowing external clients to change the configuration of the microphones.\n\n\n\n\nThese three daemons communicate together using TCP connections over UNIX sockets.\n\n\n\n\nThe Main daemon\n\n\nThis daemon can receive in live the audio streams from the microphones using ALSA API, and can also send a new configuration using the same API.\nThen it listens on two UNIX sockets using TCP: \n/tmp/micros-audio.socket\n and \n/tmp/micros-control.socket\n.\n\n\nIt sends the audio stream to every client connected to the first socket, and can receive a new audio configuration from the second socket.\nThe idea is to provide the most basic functionnalities with this daemon, that can be extended using other programs which communicate with it using these two UNIX sockets.\n\n\nWSAudio\n\n\nThe WSAudio daemon connects to the main daemon using the UNIX socket \n/tmp/micros-audio.socket\n, so it receives the audio streams in live.\nIt also listens on the port 8081 using WebSocket.\nIt will send the audio streams it receives to every connected client as binary messages.\nIt doesn't keep in memory the frames: each time it receives new data from the main daemon, it sends it to the connected clients.\nWhen a new client arrives, it starts to receive the audio streams from this moment.\n\n\nWSConfig\n\n\nThe WSConfig daemon connects to the main daemon using the UNIX socket \n/tmp/micros-control.socket\n.\nIt also listens on the port 8082 using WebSocket.\nWhen a client sends to it a configuration (using a text message containing JSON), it reads the JSON and sends the new information (using an array of integers) to the main daemon.\nThe main daemon will then interrupt its connection with ALSA, set the new configuration it just received and start again to receive the audio stream.\n\n\nOn the client\n\n\nThere are two components on the client(s):\n\n\n\n\nA python daemon \ncode-server.py\n that listens on a WebSocket and executes the python code it receives on it;\n\n\nThe webapp \nclient.html\n, which connects to \nws-audio\n and \nws-config\n so the user can listen to the audio streams and change the configuration, and also to the local python daemon to which it can send python code written by the user.\n\n\n\n\nExecution of python code\n\n\nIn the webapp, there is an editor where the user can write some python code.\nWhen he/she clicks on \nExecute\n the code is sent to the local python daemon.\nThen the python daemon includes the code to an existing python program, \nbase-program.py\n (at the end, it replaces the line \n#####INSERT: Here insert code\n with the code from the user), and executes it.\n\n\nThis new python program will then connect to \nws-audio\n, so it will receive the audio streams in live (and executes the code from the user on it), and it will also listens on a WebSocket (on a port around 9000 specified by the python daemon, which communicated it to the webapp) to which the webapp will connect.\nSo this new python program will have the possibility to work on the audio streams and to send the output (which can be plots data or a new audio stream) directly to the webapp.\n\n\nMore precisely, the user is invited to write his/her code inside a function \nhandleData(buffer)\n which will be called everytime a new audio buffer is received from the \nws-audio\n daemon.", 
            "title": "Structure"
        }, 
        {
            "location": "/structure/#intro", 
            "text": "Here is the global structure of the project, and how the different parts interact.", 
            "title": "Intro"
        }, 
        {
            "location": "/structure/#overview", 
            "text": "The system is divided in three parts:   Daemons in C running on the board;  A Python daemon running on the client computer;  A webapp executed on the client computer.   These three parts communicate using  WebSockets  (basically a TCP connection, that you can use easily in Javascript, in browsers).", 
            "title": "Overview"
        }, 
        {
            "location": "/structure/#on-the-board", 
            "text": "There are three daemons running on the board, all in C:   The  main-daemon  is the main part of the system, and the only one interacting with the microphones through ALSA API;  The  ws-audio  is a first bridge between the main daemon and a WebSocket, allowing external clients to access the audio streams;  The  ws-config  is a second bridge between the main daemon and a WebSocket, allowing external clients to change the configuration of the microphones.   These three daemons communicate together using TCP connections over UNIX sockets.", 
            "title": "On the Board"
        }, 
        {
            "location": "/structure/#the-main-daemon", 
            "text": "This daemon can receive in live the audio streams from the microphones using ALSA API, and can also send a new configuration using the same API.\nThen it listens on two UNIX sockets using TCP:  /tmp/micros-audio.socket  and  /tmp/micros-control.socket .  It sends the audio stream to every client connected to the first socket, and can receive a new audio configuration from the second socket.\nThe idea is to provide the most basic functionnalities with this daemon, that can be extended using other programs which communicate with it using these two UNIX sockets.", 
            "title": "The Main daemon"
        }, 
        {
            "location": "/structure/#wsaudio", 
            "text": "The WSAudio daemon connects to the main daemon using the UNIX socket  /tmp/micros-audio.socket , so it receives the audio streams in live.\nIt also listens on the port 8081 using WebSocket.\nIt will send the audio streams it receives to every connected client as binary messages.\nIt doesn't keep in memory the frames: each time it receives new data from the main daemon, it sends it to the connected clients.\nWhen a new client arrives, it starts to receive the audio streams from this moment.", 
            "title": "WSAudio"
        }, 
        {
            "location": "/structure/#wsconfig", 
            "text": "The WSConfig daemon connects to the main daemon using the UNIX socket  /tmp/micros-control.socket .\nIt also listens on the port 8082 using WebSocket.\nWhen a client sends to it a configuration (using a text message containing JSON), it reads the JSON and sends the new information (using an array of integers) to the main daemon.\nThe main daemon will then interrupt its connection with ALSA, set the new configuration it just received and start again to receive the audio stream.", 
            "title": "WSConfig"
        }, 
        {
            "location": "/structure/#on-the-client", 
            "text": "There are two components on the client(s):   A python daemon  code-server.py  that listens on a WebSocket and executes the python code it receives on it;  The webapp  client.html , which connects to  ws-audio  and  ws-config  so the user can listen to the audio streams and change the configuration, and also to the local python daemon to which it can send python code written by the user.", 
            "title": "On the client"
        }, 
        {
            "location": "/structure/#execution-of-python-code", 
            "text": "In the webapp, there is an editor where the user can write some python code.\nWhen he/she clicks on  Execute  the code is sent to the local python daemon.\nThen the python daemon includes the code to an existing python program,  base-program.py  (at the end, it replaces the line  #####INSERT: Here insert code  with the code from the user), and executes it.  This new python program will then connect to  ws-audio , so it will receive the audio streams in live (and executes the code from the user on it), and it will also listens on a WebSocket (on a port around 9000 specified by the python daemon, which communicated it to the webapp) to which the webapp will connect.\nSo this new python program will have the possibility to work on the audio streams and to send the output (which can be plots data or a new audio stream) directly to the webapp.  More precisely, the user is invited to write his/her code inside a function  handleData(buffer)  which will be called everytime a new audio buffer is received from the  ws-audio  daemon.", 
            "title": "Execution of python code"
        }, 
        {
            "location": "/messages-ref/", 
            "text": "Intro\n\n\nHere you will find the different messages that can be exchanged between the different parts, inside the UNIX Sockets or the WebSockets.\nThe titles are always server \n client.\n\n\nMain Daemon\n\n\nMain Daemon \n WSAudio\n\n\nThis connection is only one-way: the main daemon sends messages to WSAudio.\n\n\nConnection\n\n\n\n\nSocket Type: UNIX Socket;\n\n\nFile: \n/tmp/micros-audio.socket\n;\n\n\nTransport protocol: TCP.\n\n\n\n\nMessages\n\n\n\n\nAudio configuration: this message allows WSAudio to know the audio configuration choosed, so especially it can allocate the right buffer size.\n\n\nLength in \nbytes\n: \n4*sizeof(int)\n;\n\n\nPayload: four integer: \n{buffer_frames}{rate}{channels}{volume}\n:\n\n\nbuffer_frames\n: number of audio frames in one buffer;\n\n\nrate\n: audio rate (in bits/second);\n\n\nchannels\n: number of channels;\n\n\nvolume\n: ALSA volume of all microphones, between 0 and 100.\n\n\n\n\n\n\nSo the size of the audio buffer is \nbuffer_size = buffer_frames*channels*sizeof(SND_PCM_FORMAT_S16_LE) / 8\n in \nbytes\n (for now, one audio frame is encoded with a 16-bits little-endian integer).\n\n\n\n\n\n\nAudio buffer: this message contains new audio data.\n\n\nLength: the previous computed \nbuffer_size\n;\n\n\nPayload: \nbuffer_frames*channels\n 16-bits little-endian integer, in the following order (for example with 2 channels):\n\n\nframes[0].channels[0];\n\n\nframes[0].channels[1];\n\n\nframes[1].channels[0];\n\n\nframes[1].channels[1];\n\n\nframes[2].channels[0];\n\n\nframes[2].channels[1];\n\n\n...\n\n\n\n\n\n\n\n\n\n\n\n\nTo differentiate the two messages types, WSAudio only uses the length of the message.\nIf it's four integers then it is a configuration information, else it is audio data.\n\n\nMain Daemon \n WSConfig\n\n\nThis connection is only one-way: WSConfig sends messages to the main daemon.\n\n\nConnection\n\n\n\n\nSocket Type: UNIX Socket;\n\n\nFile: \n/tmp/micros-config.socket\n;\n\n\nTransport protocol: TCP.\n\n\n\n\nMessages\n\n\n\n\nAudio configuration: this message allows WSConfig to send a new audio configuration to the main daemon.\n\n\nLength in \nbytes\n: \n4*sizeof(int)\n;\n\n\nPayload: four integer: \n{buffer_frames}{rate}{channels}{volume}\n:\n\n\nbuffer_frames\n: number of audio frames in one buffer;\n\n\nrate\n: audio rate (in bits/second);\n\n\nchannels\n: number of channels;\n\n\nvolume\n: ALSA volume of all microphones, between 0 and 100.\n\n\n\n\n\n\n\n\n\n\n\n\nWSAudio \n Client\n\n\nThis connection is only one-way: WSAudio sends messages to the webapp or the python program.\n\n\nConnection\n\n\n\n\nProtocol: WebSocket;\n\n\nPort: 8081.\n\n\n\n\nMessages\n\n\n\n\n\n\nAudio configuration: this message allows the client to know the audio configuration choosed.\n\n\n\n\nMessage type: text;\n\n\n\n\nMessage format: JSON:\n\n\n{\n  \"buffer_frames\": (integer), // the number of frames in one buffer\n  \"rate\": (integer), // the bitrate in bits/second\n  \"channels\": (integer), // the number of channels\n  \"volume\": (integer) // the volume of all microphones, between 0 and 100\n}\n\n\n\n\n\n\n\nSo the size of the audio buffer is \nm.buffer_frames * m.channels * 16 / 8\n in \nbytes\n (16 because a frame is encoded using a 16-bits little-endian integer), where \nm\n is the JSON received message.\n\n\n\n\n\n\n\n\n\n\nAudio buffer: this message contains new audio data.\n\n\n\n\nMessage type: binary;\n\n\nPayload: \nm.buffer_frames * m.channels\n 16-bits little-endian integer, in the following order (for example with 2 channels):\n\n\nframes[0].channels[0];\n\n\nframes[0].channels[1];\n\n\nframes[1].channels[0];\n\n\nframes[1].channels[1];\n\n\nframes[2].channels[0];\n\n\nframes[2].channels[1];\n\n\n...\n\n\n\n\n\n\n\n\n\n\n\n\nWSConfig \n Webapp\n\n\nThis connection is only one-way: the webapp sends new audio configuration to WSConfig\n\n\nConnection\n\n\n\n\nProtocol: WebSocket;\n\n\nPort: 8082.\n\n\n\n\nMessages\n\n\n\n\nAudio configuration: this message allows the webapp to send a new audio configuration to WSConfig.\n\n\nMessage type: text;\n\n\nMessage format: JSON:\n{\n  \"buffer_frames\": (integer), // the number of frames in one buffer\n  \"rate\": (integer), // the bitrate in bits/second\n  \"channels\": (integer), // the number of channels\n  \"volume\": (integer) // the volume of all microphones, between 0 and 100\n}\n\n\n\n\n\n\n\n\n\n\n\nPython Daemon \n Webapp\n\n\nThis conenction is two-ways: the webapp can send new python code to execute, and the daemon can send back the status of the program.\n\n\nConnection\n\n\n\n\nProtocol: WebSocket;\n\n\nPort: 9000.\n\n\n\n\nMessages: Webapp \n Python Daemon\n\n\n\n\n\n\nPython code to execute: this message contains new python code to insert into \nbase-program.py\n and to execute.\n\n\n\n\nMessage type: text;\n\n\nPayload: just the python code to execute.\n\n\n\n\n\n\n\n\nInterruption of the running code: this messages asks the daemon to stop the current python code running (each client can only have one python program running at each time).\n\n\n\n\nMessage type: text;\n\n\nPayload: just \nSTOP\n.\n\n\n\n\n\n\n\n\nMessages: Python Daemon \n Webapp\n\n\n\n\n\n\nPort information: this message indicates to the webapp on which port the new python program will listen for its WebSocket.\n\n\n\n\nMessage type: text;\n\n\nMessage format: JSON: \n{\"port\": (integer)}\n.\n\n\n\n\n\n\n\n\nStdout new line: this message is sent to the webapp each time the new python program outputs a line on stdout.\n\n\n\n\nMessage type: text;\n\n\nMessage format: JSON: \n{\"line\": (string)}\n.\n\n\n\n\n\n\n\n\nStderr new line: this message is sent to the webapp each time the new python program outputs a line on stderr.\n\n\n\n\nMessage type: text;\n\n\nMessage format: JSON: \n{\"error\": (string)}\n.\n\n\n\n\n\n\n\n\nLine inserted: this message indicates to the webapp on which line of \nbase-program.py\n the python code has been inserted (it is usefull to find the correspondance between an error and the original line).\n\n\n\n\nMessage type: text;\n\n\nMessage format: JSON: \n{\"codeLine\": (integer)}\n.\n\n\n\n\n\n\n\n\nEnd of the python program: this message is sent to the webapp when the new python program exits, with the code returned.\n\n\n\n\nMessage type: text;\n\n\nMessage format: JSON: \n{\"status\": \"end\", \"code\": (integer)}\n.\n\n\n\n\n\n\n\n\nfinal-program.py \n Webapp\n\n\nThis connection is one-way only: the new python program can send various outputs to the webapp.\n\n\nConnection\n\n\n\n\nProtocol: WebSocket;\n\n\nPort: just over 9000 (choosen and specified by the python daemon).\n\n\n\n\nMessages\n\n\n\n\n\n\nAudio data to play: this message contains a new audio buffer. The python program can for example to something on the audio stream and outputs a new audio stream it wants the webapp to play.\n\n\n\n\nMessage type: binary;\n\n\nPayload: for now, the configuration must be the same as the input stream: \ninput_conf.buffer_frames * input_conf.channels\n 16-bits little-endian integer, in the following order (for example with 2 channels):\n\n\nframes[0].channels[0];\n\n\nframes[0].channels[1];\n\n\nframes[1].channels[0];\n\n\nframes[1].channels[1];\n\n\nframes[2].channels[0];\n\n\nframes[2].channels[1];\n\n\n...\n\n\n\n\n\n\n\n\n\n\n\n\nCreation of a new data handler: this message asks the webapp to create a new data handler, that will be then complete with new data.\n\n\n\n\nMessage type: text;\n\n\nMessage format: JSON:\n{\n    \"addHandler\": (string), // name of the handler for display\n    \"id\": (integer), // id chosen to identify the handler. Must be unique\n    \"type\": (string), // type of handler\n    \"parameters\": (object) // optional parameters\n}\n\n\n\n\n\n\n\n\n\n\n\nNew data for a data handler: this message contains new data for an existing data handler.\n\n\n\n\nMessage type: text;\n\n\nMessage format: JSON:\n{\n    \"dataHandler\": (integer), // id of the existing data handler\n    \"data\": (object) // data for the existing data handler\n}", 
            "title": "Messages reference"
        }, 
        {
            "location": "/messages-ref/#intro", 
            "text": "Here you will find the different messages that can be exchanged between the different parts, inside the UNIX Sockets or the WebSockets.\nThe titles are always server   client.", 
            "title": "Intro"
        }, 
        {
            "location": "/messages-ref/#main-daemon", 
            "text": "", 
            "title": "Main Daemon"
        }, 
        {
            "location": "/messages-ref/#main-daemon-wsaudio", 
            "text": "This connection is only one-way: the main daemon sends messages to WSAudio.", 
            "title": "Main Daemon &gt; WSAudio"
        }, 
        {
            "location": "/messages-ref/#connection", 
            "text": "Socket Type: UNIX Socket;  File:  /tmp/micros-audio.socket ;  Transport protocol: TCP.", 
            "title": "Connection"
        }, 
        {
            "location": "/messages-ref/#messages", 
            "text": "Audio configuration: this message allows WSAudio to know the audio configuration choosed, so especially it can allocate the right buffer size.  Length in  bytes :  4*sizeof(int) ;  Payload: four integer:  {buffer_frames}{rate}{channels}{volume} :  buffer_frames : number of audio frames in one buffer;  rate : audio rate (in bits/second);  channels : number of channels;  volume : ALSA volume of all microphones, between 0 and 100.    So the size of the audio buffer is  buffer_size = buffer_frames*channels*sizeof(SND_PCM_FORMAT_S16_LE) / 8  in  bytes  (for now, one audio frame is encoded with a 16-bits little-endian integer).    Audio buffer: this message contains new audio data.  Length: the previous computed  buffer_size ;  Payload:  buffer_frames*channels  16-bits little-endian integer, in the following order (for example with 2 channels):  frames[0].channels[0];  frames[0].channels[1];  frames[1].channels[0];  frames[1].channels[1];  frames[2].channels[0];  frames[2].channels[1];  ...       To differentiate the two messages types, WSAudio only uses the length of the message.\nIf it's four integers then it is a configuration information, else it is audio data.", 
            "title": "Messages"
        }, 
        {
            "location": "/messages-ref/#main-daemon-wsconfig", 
            "text": "This connection is only one-way: WSConfig sends messages to the main daemon.", 
            "title": "Main Daemon &lt; WSConfig"
        }, 
        {
            "location": "/messages-ref/#connection_1", 
            "text": "Socket Type: UNIX Socket;  File:  /tmp/micros-config.socket ;  Transport protocol: TCP.", 
            "title": "Connection"
        }, 
        {
            "location": "/messages-ref/#messages_1", 
            "text": "Audio configuration: this message allows WSConfig to send a new audio configuration to the main daemon.  Length in  bytes :  4*sizeof(int) ;  Payload: four integer:  {buffer_frames}{rate}{channels}{volume} :  buffer_frames : number of audio frames in one buffer;  rate : audio rate (in bits/second);  channels : number of channels;  volume : ALSA volume of all microphones, between 0 and 100.", 
            "title": "Messages"
        }, 
        {
            "location": "/messages-ref/#wsaudio-client", 
            "text": "This connection is only one-way: WSAudio sends messages to the webapp or the python program.", 
            "title": "WSAudio &gt; Client"
        }, 
        {
            "location": "/messages-ref/#connection_2", 
            "text": "Protocol: WebSocket;  Port: 8081.", 
            "title": "Connection"
        }, 
        {
            "location": "/messages-ref/#messages_2", 
            "text": "Audio configuration: this message allows the client to know the audio configuration choosed.   Message type: text;   Message format: JSON:  {\n  \"buffer_frames\": (integer), // the number of frames in one buffer\n  \"rate\": (integer), // the bitrate in bits/second\n  \"channels\": (integer), // the number of channels\n  \"volume\": (integer) // the volume of all microphones, between 0 and 100\n}    So the size of the audio buffer is  m.buffer_frames * m.channels * 16 / 8  in  bytes  (16 because a frame is encoded using a 16-bits little-endian integer), where  m  is the JSON received message.      Audio buffer: this message contains new audio data.   Message type: binary;  Payload:  m.buffer_frames * m.channels  16-bits little-endian integer, in the following order (for example with 2 channels):  frames[0].channels[0];  frames[0].channels[1];  frames[1].channels[0];  frames[1].channels[1];  frames[2].channels[0];  frames[2].channels[1];  ...", 
            "title": "Messages"
        }, 
        {
            "location": "/messages-ref/#wsconfig-webapp", 
            "text": "This connection is only one-way: the webapp sends new audio configuration to WSConfig", 
            "title": "WSConfig &lt; Webapp"
        }, 
        {
            "location": "/messages-ref/#connection_3", 
            "text": "Protocol: WebSocket;  Port: 8082.", 
            "title": "Connection"
        }, 
        {
            "location": "/messages-ref/#messages_3", 
            "text": "Audio configuration: this message allows the webapp to send a new audio configuration to WSConfig.  Message type: text;  Message format: JSON: {\n  \"buffer_frames\": (integer), // the number of frames in one buffer\n  \"rate\": (integer), // the bitrate in bits/second\n  \"channels\": (integer), // the number of channels\n  \"volume\": (integer) // the volume of all microphones, between 0 and 100\n}", 
            "title": "Messages"
        }, 
        {
            "location": "/messages-ref/#python-daemon-webapp", 
            "text": "This conenction is two-ways: the webapp can send new python code to execute, and the daemon can send back the status of the program.", 
            "title": "Python Daemon &lt;&gt; Webapp"
        }, 
        {
            "location": "/messages-ref/#connection_4", 
            "text": "Protocol: WebSocket;  Port: 9000.", 
            "title": "Connection"
        }, 
        {
            "location": "/messages-ref/#messages-webapp-python-daemon", 
            "text": "Python code to execute: this message contains new python code to insert into  base-program.py  and to execute.   Message type: text;  Payload: just the python code to execute.     Interruption of the running code: this messages asks the daemon to stop the current python code running (each client can only have one python program running at each time).   Message type: text;  Payload: just  STOP .", 
            "title": "Messages: Webapp &gt; Python Daemon"
        }, 
        {
            "location": "/messages-ref/#messages-python-daemon-webapp", 
            "text": "Port information: this message indicates to the webapp on which port the new python program will listen for its WebSocket.   Message type: text;  Message format: JSON:  {\"port\": (integer)} .     Stdout new line: this message is sent to the webapp each time the new python program outputs a line on stdout.   Message type: text;  Message format: JSON:  {\"line\": (string)} .     Stderr new line: this message is sent to the webapp each time the new python program outputs a line on stderr.   Message type: text;  Message format: JSON:  {\"error\": (string)} .     Line inserted: this message indicates to the webapp on which line of  base-program.py  the python code has been inserted (it is usefull to find the correspondance between an error and the original line).   Message type: text;  Message format: JSON:  {\"codeLine\": (integer)} .     End of the python program: this message is sent to the webapp when the new python program exits, with the code returned.   Message type: text;  Message format: JSON:  {\"status\": \"end\", \"code\": (integer)} .", 
            "title": "Messages: Python Daemon &gt; Webapp"
        }, 
        {
            "location": "/messages-ref/#final-programpy-webapp", 
            "text": "This connection is one-way only: the new python program can send various outputs to the webapp.", 
            "title": "final-program.py &gt; Webapp"
        }, 
        {
            "location": "/messages-ref/#connection_5", 
            "text": "Protocol: WebSocket;  Port: just over 9000 (choosen and specified by the python daemon).", 
            "title": "Connection"
        }, 
        {
            "location": "/messages-ref/#messages_4", 
            "text": "Audio data to play: this message contains a new audio buffer. The python program can for example to something on the audio stream and outputs a new audio stream it wants the webapp to play.   Message type: binary;  Payload: for now, the configuration must be the same as the input stream:  input_conf.buffer_frames * input_conf.channels  16-bits little-endian integer, in the following order (for example with 2 channels):  frames[0].channels[0];  frames[0].channels[1];  frames[1].channels[0];  frames[1].channels[1];  frames[2].channels[0];  frames[2].channels[1];  ...       Creation of a new data handler: this message asks the webapp to create a new data handler, that will be then complete with new data.   Message type: text;  Message format: JSON: {\n    \"addHandler\": (string), // name of the handler for display\n    \"id\": (integer), // id chosen to identify the handler. Must be unique\n    \"type\": (string), // type of handler\n    \"parameters\": (object) // optional parameters\n}      New data for a data handler: this message contains new data for an existing data handler.   Message type: text;  Message format: JSON: {\n    \"dataHandler\": (integer), // id of the existing data handler\n    \"data\": (object) // data for the existing data handler\n}", 
            "title": "Messages"
        }, 
        {
            "location": "/python-reference/", 
            "text": "Intro\n\n\nThis part explains how to get the audio streams in python code and how to send results to the webapp, so it can display them in live.\n\n\nHow it works\n\n\nIt is important to understand that the code written in the editor in the webapp will be inserted in the file \nbase-program.py\n, at the line \n#####INSERT: Here insert code\n.\nSo pre-existing functions and variables will be accessible, whereas you will not see them in the editor.\n\n\nReading the configuration\n\n\nFour variables contain the configuration:\n\n\n\n\nrate\n: the rate in bits/second;\n\n\nchannels\n: the number of channels;\n\n\nbuffer_frames\n: the number of audio frames contained in one buffer;\n\n\nvolume\n: the volume between 0 and 100.\n\n\n\n\nThese are read-only, and you must not change them!\n\n\nReceiving the audio streams\n\n\nA function \nhandleData(buffer)\n must be defined in your code.\nIt will be called each time a new audio buffer is received.\n\n\nThe parameter \nbuffer\n will contain an array of size \nbuffer_frames\n containing arrays of size \nchannels\n containing integers between -32 767 and +32 767.\n\n\nAn example with 5 frames per buffer and 2 channels:\n\n\n[\n  [100, 300],\n  [80, 240],\n  [130, 0],\n  [-800, 123],\n  [-400, 0]\n]\n\n\n\n\nUsing the data handlers\n\n\nAfter you performed some algorithms on the audio streams, you may want to display some outputs, like charts, histograms or new audio streams.\nWhat you have to do is to send the data you want to display to a \ndata handler\n of the webapp.\nYou have two simple steps to do:\n\n\n\n\nYou create a new data handler using the function \naddHandler(name, type, parameters)\n which returns an object representing this new instance;\n\n\nYou send data to this instance using its method \nsendData(data)\n.\n\n\n\n\nOnce you call the function \naddHandler\n, a new tab will be created in the webapp, with the name \nname\n you specified, and the chart/plot/audio player will appear inside.\nYou can use the part \nData Handlers\n to see which \ntypes\n of data handlers exist, which parameters are supported, and which structure the \ndata\n you send must follow.", 
            "title": "Python reference"
        }, 
        {
            "location": "/python-reference/#intro", 
            "text": "This part explains how to get the audio streams in python code and how to send results to the webapp, so it can display them in live.", 
            "title": "Intro"
        }, 
        {
            "location": "/python-reference/#how-it-works", 
            "text": "It is important to understand that the code written in the editor in the webapp will be inserted in the file  base-program.py , at the line  #####INSERT: Here insert code .\nSo pre-existing functions and variables will be accessible, whereas you will not see them in the editor.", 
            "title": "How it works"
        }, 
        {
            "location": "/python-reference/#reading-the-configuration", 
            "text": "Four variables contain the configuration:   rate : the rate in bits/second;  channels : the number of channels;  buffer_frames : the number of audio frames contained in one buffer;  volume : the volume between 0 and 100.   These are read-only, and you must not change them!", 
            "title": "Reading the configuration"
        }, 
        {
            "location": "/python-reference/#receiving-the-audio-streams", 
            "text": "A function  handleData(buffer)  must be defined in your code.\nIt will be called each time a new audio buffer is received.  The parameter  buffer  will contain an array of size  buffer_frames  containing arrays of size  channels  containing integers between -32 767 and +32 767.  An example with 5 frames per buffer and 2 channels:  [\n  [100, 300],\n  [80, 240],\n  [130, 0],\n  [-800, 123],\n  [-400, 0]\n]", 
            "title": "Receiving the audio streams"
        }, 
        {
            "location": "/python-reference/#using-the-data-handlers", 
            "text": "After you performed some algorithms on the audio streams, you may want to display some outputs, like charts, histograms or new audio streams.\nWhat you have to do is to send the data you want to display to a  data handler  of the webapp.\nYou have two simple steps to do:   You create a new data handler using the function  addHandler(name, type, parameters)  which returns an object representing this new instance;  You send data to this instance using its method  sendData(data) .   Once you call the function  addHandler , a new tab will be created in the webapp, with the name  name  you specified, and the chart/plot/audio player will appear inside.\nYou can use the part  Data Handlers  to see which  types  of data handlers exist, which parameters are supported, and which structure the  data  you send must follow.", 
            "title": "Using the data handlers"
        }, 
        {
            "location": "/data-handlers/", 
            "text": "Definition\n\n\nA data handler is an object in the webapp which can be used to handle some data.\n\n\nTypically, they are used to vizualise the output of the program written by the user, which takes into input the audio streams, and could want to draw some charts as a result.\nSeveral data handlers come with the project, but you can also easily write your own, as explained.\n\n\nThere are two main parts when using a data handler:\n\n\n\n\nYou create it, with some configuration information;\n\n\nYou send data to it.\n\n\n\n\nExample\n\n\nYou can use the data handlers from your python code (it is defined in more details in the python part reference):\n\n\nimport time\nimport random\n\n# First, we create our handlers\n# First we precise the name, then the type, and third the possible parameters\n## A line chart, with two series\nc1 = addHandler(\nFirst chart - Line\n, 'base:graph:line', {'xName': 'Name of x axis', 'series': ['First serie', 'Second serie']})\n## A plot chart, with one serie\nc2 = addHandler(\nSecond chart - Plot\n, 'base:graph:plot', {'xName': 'Name of super x axis', 'series': ['Only serie']})\n## A polar chart, with one serie\nc3 = addHandler(\nThird chart - Polar\n, 'base:polar:area', {'title': 'Awesome polar chart', 'series': ['Intensity'], 'legend': {'from': 0, 'to': 360, 'step': 10}})\n\n# Then we can send some data to the different handlers\nc1.sendData([{'x': 1, 'y': 89}, {'x': 1, 'y': 39}])\nc1.sendData([{'x': 2, 'y': 70}, {'x': 2, 'y': 20}])\nc1.sendData([{'x': 3, 'y': 40}, {'x': 3, 'y': -2}])\nc1.sendData([{'x': 4, 'y': 2}, {'x': 4, 'y': 4}])\nc2.sendData([{'x': -4, 'y': 3}])\n\nfor i in range(5, 40):\n  c1.sendData([{'x': i, 'y': 20+i*5*random.random()}, {'x': i, 'y': i*5*random.random()}])\n  c3.sendData([{'append': (200+i*3)*10}])\n  time.sleep(1)\n\n\n\n\nDataHandler: draw classic charts\n\n\nThis handler can be used to draw line charts, histograms.\nThere are always 2D charts, with an x axis and an y axis.\n\n\n\n\n\n\n\n\nTypes\n\n\n\n\nbase:graph:line\n: a line chart;\n\n\nbase:graph:area\n: an area chart;\n\n\nbase:graph:bar\n: an histogram;\n\n\nbase:graph:plot\n: a plot chart.\n\n\n\n\nConfiguration\n\n\nThe following options are accepted during the creation:\n\n\n\n\nxName\n (string): name of the x axis;\n\n\nseries\n (array[string]): names of the different series. \nThis parameter fixes the number of series to display\n;\n\n\nmin\n (number) [optional]: minimum value for y;\n\n\nmax\n (number) [optional]: maximum value for y.\n\n\n\n\nSending data\n\n\nAdding a point\n\n\nYou can add a new point to each serie:\n\n\n[\n  {\nx\n: 3, \ny\n: 39},\n  {\nx\n: 3, \ny\n: -3},\n  {\nx\n: 3, \ny\n: 23.1}\n]\n\n\n\n\nThe size of the array must be the number of series (specified during the creation).\n\n\nReplacing all the points\n\n\nYou can also replace all the points of all the series:\n\n\n{\n  \nx\n: [0, 1, 2, 3, 4],\n  \ny\n: [\n    [12, 4, 1, 1, 5],\n    [6, 4, 2, 0, -2],\n    [0, 0.5, 1, 0.5, 2]\n  ]\n}\n\n\n\n\nHere we have three series of five points.\nEach serie must have the same number of points, matching the length of the \nx\n array.\n\n\nDataHandler: draw polar charts\n\n\nThis handler can draw polar charts (simple ones for now).\n\n\n\n\nTypes\n\n\n\n\nbase:polar:area\n: an area polar chart.\n\n\n\n\nConfiguration\n\n\nThe following options are accepted during the creation:\n\n\n\n\ntitle\n (string): name of the chart;\n\n\nseries\n (array[string]): names of the different series. \nThis parameter fixes the number of series to display\n;\n\n\nlegend\n (object): defines the scale and contains the following parameters:\n\n\nfrom\n (number): the value corresponding to a start from the north;\n\n\nto\n (number): the value corresponding to the arrival to the north after one revolution;\n\n\nstep\n (number): the size of the subdivision.\n\n\n\n\n\n\n\n\nSending data\n\n\nAdding an entry\n\n\nYou can add new data to each serie:\n\n\n[\n  {\nappend\n: 10},\n  {\nappend\n: 4},\n  {\nappend\n: 43}\n]\n\n\n\n\nThe size of the array must be the number of series (specified during the creation).\nThe new values will be pushed at the end of previous data of each serie.\n\n\nWrite your own data handler\n\n\nFrom a code point of view, a data handler is a class, from which instances are created when asking.\nBecause we are talking about JavaScript, we are not working with a real class, but with a function returning an object.\n\n\nDefining your data handler\n\n\nWhen instantiated, two parameters will be given to your function:\n\n the html element you can use to display things;\n\n the \nparameters\n object specified by the user.\n\n\nYour function must return an objet with a property/method \nnewData\n that will be called with the \ndata\n object specified by the user.\n\n\nfunction myDataHandler(html, parameters) {\n  // html is the DOM element you can use\n  // Here we just append to this html element the parameters object\n  $(html).append(JSON.stringify(parameters) + '\nbr /\n');\n\n  // We must return an object with a method newData\n  return {\n    newData: function (data) {\n      // This code will be executed each time data is sent to this data handler\n      $(html).append(JSON.stringify(data) + '\nbr /\n');\n    }\n  }\n}\n\n\n\n\nRegistering your data handler\n\n\nThen, you have to choose a type for your data handler and to register it:\n\n\ndataHandlers.registerNewType('customtype', myDataHandler);\n\n\n\n\nYou can write this code in the file \njs/myHandlers.js\n\n\nUsing it\n\n\nYou can use it from the python code like any other data handler:\n\n\nmyHandlerInstance = addHandler(\nCustom thing\n, 'customtype', {'param1': True, 'param2': 'hello', 'param3': [0, 1, 2]})\nmyHandlerInstance.sendData({'newData': {'i': i}})\nmyHandlerInstance.sendData(['an', 'array', 'this', 'time'])", 
            "title": "Data Handlers"
        }, 
        {
            "location": "/data-handlers/#definition", 
            "text": "A data handler is an object in the webapp which can be used to handle some data.  Typically, they are used to vizualise the output of the program written by the user, which takes into input the audio streams, and could want to draw some charts as a result.\nSeveral data handlers come with the project, but you can also easily write your own, as explained.  There are two main parts when using a data handler:   You create it, with some configuration information;  You send data to it.", 
            "title": "Definition"
        }, 
        {
            "location": "/data-handlers/#example", 
            "text": "You can use the data handlers from your python code (it is defined in more details in the python part reference):  import time\nimport random\n\n# First, we create our handlers\n# First we precise the name, then the type, and third the possible parameters\n## A line chart, with two series\nc1 = addHandler( First chart - Line , 'base:graph:line', {'xName': 'Name of x axis', 'series': ['First serie', 'Second serie']})\n## A plot chart, with one serie\nc2 = addHandler( Second chart - Plot , 'base:graph:plot', {'xName': 'Name of super x axis', 'series': ['Only serie']})\n## A polar chart, with one serie\nc3 = addHandler( Third chart - Polar , 'base:polar:area', {'title': 'Awesome polar chart', 'series': ['Intensity'], 'legend': {'from': 0, 'to': 360, 'step': 10}})\n\n# Then we can send some data to the different handlers\nc1.sendData([{'x': 1, 'y': 89}, {'x': 1, 'y': 39}])\nc1.sendData([{'x': 2, 'y': 70}, {'x': 2, 'y': 20}])\nc1.sendData([{'x': 3, 'y': 40}, {'x': 3, 'y': -2}])\nc1.sendData([{'x': 4, 'y': 2}, {'x': 4, 'y': 4}])\nc2.sendData([{'x': -4, 'y': 3}])\n\nfor i in range(5, 40):\n  c1.sendData([{'x': i, 'y': 20+i*5*random.random()}, {'x': i, 'y': i*5*random.random()}])\n  c3.sendData([{'append': (200+i*3)*10}])\n  time.sleep(1)", 
            "title": "Example"
        }, 
        {
            "location": "/data-handlers/#datahandler-draw-classic-charts", 
            "text": "This handler can be used to draw line charts, histograms.\nThere are always 2D charts, with an x axis and an y axis.", 
            "title": "DataHandler: draw classic charts"
        }, 
        {
            "location": "/data-handlers/#types", 
            "text": "base:graph:line : a line chart;  base:graph:area : an area chart;  base:graph:bar : an histogram;  base:graph:plot : a plot chart.", 
            "title": "Types"
        }, 
        {
            "location": "/data-handlers/#configuration", 
            "text": "The following options are accepted during the creation:   xName  (string): name of the x axis;  series  (array[string]): names of the different series.  This parameter fixes the number of series to display ;  min  (number) [optional]: minimum value for y;  max  (number) [optional]: maximum value for y.", 
            "title": "Configuration"
        }, 
        {
            "location": "/data-handlers/#sending-data", 
            "text": "", 
            "title": "Sending data"
        }, 
        {
            "location": "/data-handlers/#adding-a-point", 
            "text": "You can add a new point to each serie:  [\n  { x : 3,  y : 39},\n  { x : 3,  y : -3},\n  { x : 3,  y : 23.1}\n]  The size of the array must be the number of series (specified during the creation).", 
            "title": "Adding a point"
        }, 
        {
            "location": "/data-handlers/#replacing-all-the-points", 
            "text": "You can also replace all the points of all the series:  {\n   x : [0, 1, 2, 3, 4],\n   y : [\n    [12, 4, 1, 1, 5],\n    [6, 4, 2, 0, -2],\n    [0, 0.5, 1, 0.5, 2]\n  ]\n}  Here we have three series of five points.\nEach serie must have the same number of points, matching the length of the  x  array.", 
            "title": "Replacing all the points"
        }, 
        {
            "location": "/data-handlers/#datahandler-draw-polar-charts", 
            "text": "This handler can draw polar charts (simple ones for now).", 
            "title": "DataHandler: draw polar charts"
        }, 
        {
            "location": "/data-handlers/#types_1", 
            "text": "base:polar:area : an area polar chart.", 
            "title": "Types"
        }, 
        {
            "location": "/data-handlers/#configuration_1", 
            "text": "The following options are accepted during the creation:   title  (string): name of the chart;  series  (array[string]): names of the different series.  This parameter fixes the number of series to display ;  legend  (object): defines the scale and contains the following parameters:  from  (number): the value corresponding to a start from the north;  to  (number): the value corresponding to the arrival to the north after one revolution;  step  (number): the size of the subdivision.", 
            "title": "Configuration"
        }, 
        {
            "location": "/data-handlers/#sending-data_1", 
            "text": "", 
            "title": "Sending data"
        }, 
        {
            "location": "/data-handlers/#adding-an-entry", 
            "text": "You can add new data to each serie:  [\n  { append : 10},\n  { append : 4},\n  { append : 43}\n]  The size of the array must be the number of series (specified during the creation).\nThe new values will be pushed at the end of previous data of each serie.", 
            "title": "Adding an entry"
        }, 
        {
            "location": "/data-handlers/#write-your-own-data-handler", 
            "text": "From a code point of view, a data handler is a class, from which instances are created when asking.\nBecause we are talking about JavaScript, we are not working with a real class, but with a function returning an object.", 
            "title": "Write your own data handler"
        }, 
        {
            "location": "/data-handlers/#defining-your-data-handler", 
            "text": "When instantiated, two parameters will be given to your function:  the html element you can use to display things;  the  parameters  object specified by the user.  Your function must return an objet with a property/method  newData  that will be called with the  data  object specified by the user.  function myDataHandler(html, parameters) {\n  // html is the DOM element you can use\n  // Here we just append to this html element the parameters object\n  $(html).append(JSON.stringify(parameters) + ' br / ');\n\n  // We must return an object with a method newData\n  return {\n    newData: function (data) {\n      // This code will be executed each time data is sent to this data handler\n      $(html).append(JSON.stringify(data) + ' br / ');\n    }\n  }\n}", 
            "title": "Defining your data handler"
        }, 
        {
            "location": "/data-handlers/#registering-your-data-handler", 
            "text": "Then, you have to choose a type for your data handler and to register it:  dataHandlers.registerNewType('customtype', myDataHandler);  You can write this code in the file  js/myHandlers.js", 
            "title": "Registering your data handler"
        }, 
        {
            "location": "/data-handlers/#using-it", 
            "text": "You can use it from the python code like any other data handler:  myHandlerInstance = addHandler( Custom thing , 'customtype', {'param1': True, 'param2': 'hello', 'param3': [0, 1, 2]})\nmyHandlerInstance.sendData({'newData': {'i': i}})\nmyHandlerInstance.sendData(['an', 'array', 'this', 'time'])", 
            "title": "Using it"
        }
    ]
}